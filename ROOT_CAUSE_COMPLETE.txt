================================================================================
COMPLETE ROOT CAUSE ANALYSIS - ORDER_ID FIELDS
================================================================================

CONFIRMED FACTS FROM DATABASE:
-------------------------------

1. ORDERS TABLE HAS TWO ID FIELDS:
   ✓ id (UUID, PRIMARY KEY) - Generated by database: "659e74cc-610f-4bb6-ab0c-6e5b7f09d1ee"
   ✓ order_id (VARCHAR) - From VirtualOrder object: "7e1398fd-2870-4cc4-9810-e5dfe2ad4bc8"

2. POSITIONS TABLE HAS ORDER REFERENCES:
   ✓ buy_order_id (UUID) - References orders.id (PRIMARY KEY)
   ✓ sell_order_id (UUID) - References orders.id (PRIMARY KEY)
   ✓ ALL positions have buy_order_id populated (100%)
   ✓ Foreign key relationships are VALID and WORKING

3. THE ORPHANED ORDER:
   ✓ Exists in orders table with BOTH IDs populated correctly
   ✓ Has NO corresponding position in positions table
   ✓ signal_data does NOT contain 'database_id' field

================================================================================
THE ACTUAL BUG - CODE FLOW ANALYSIS
================================================================================

WHAT THE CODE DOES:
-------------------

Line 485: order_id = str(uuid.uuid4())  # Generate: "7e1398fd-..."
Line 486: order_data['order_id'] = order_id  # Save to database as VARCHAR

Line 500: saved_order_id = save_order(order_data)
         # Returns database PRIMARY KEY: "659e74cc-..."

Line 514: order.metadata['database_id'] = saved_order_id
         # Store in MEMORY only!
         # This is NEVER saved to database!

Line 632: database_order_id = order.metadata.get('database_id')
         # Tries to read from metadata...

THE PROBLEM:
------------

The code at line 514 stores database_id in order.metadata (IN-MEMORY).
But when position creation happens at line 632, it reads from the same
in-memory order object.

IF this works correctly (14 out of 15 times), the flow is:
1. Order saved → saved_order_id returned: "659e74cc-..."
2. Stored in memory: order.metadata['database_id'] = "659e74cc-..."
3. Position reads it: order.metadata.get('database_id') = "659e74cc-..."
4. Position created with buy_order_id = "659e74cc-..." ✅

BUT when it FAILS (1 out of 15 times):
1. Order saved → saved_order_id returned: "659e74cc-..."
2. Something goes wrong before line 514 executes, OR
3. order.metadata is not the same object when read at line 632
4. Position reads: order.metadata.get('database_id') = None ❌
5. Exception raised: "Cannot create position without database order ID"
6. Exception caught and swallowed at line 664 ❌

================================================================================
WHY YOUR QUESTION IS IMPORTANT
================================================================================

YOU ASKED: "order_id is already saved in database, can't we use that?"

YES! You're absolutely right! Here's what we CAN use:

OPTION 1 - Use saved_order_id directly:
----------------------------------------
The saved_order_id is ALREADY AVAILABLE at line 500!
We don't need to store it in metadata and retrieve it later.

Current code:
  Line 500: saved_order_id = save_order(order_data)  ✅ WE HAVE IT!
  Line 514: order.metadata['database_id'] = saved_order_id  ❌ UNNECESSARY!
  Line 568: _update_position(order, trade)  ← Pass saved_order_id here!
  Line 632: database_order_id = order.metadata.get('database_id')  ❌ FAILS!

Fixed approach:
  Line 500: saved_order_id = save_order(order_data)  ✅
  Line 568: _update_position(order, trade, saved_order_id)  ✅ PASS DIRECTLY!
  Line 632: Use the saved_order_id parameter  ✅ ALWAYS WORKS!

OPTION 2 - Query database using order.order_id:
------------------------------------------------
Since order.order_id (the VARCHAR field) is also saved:
  Line 486: order_data['order_id'] = order_id  # "7e1398fd-..."
  Line 632: Query: SELECT id FROM orders WHERE order_id = order.order_id
  
This would find: "659e74cc-..." (the PRIMARY KEY)

OPTION 3 - Store database_id in signal_data:
---------------------------------------------
When saving order at line 500, include database_id in signal_data:
  order_data['signal_data']['database_id'] = saved_order_id
  
Then it's persisted to database and can be retrieved later.

================================================================================
RECOMMENDED SOLUTION
================================================================================

OPTION 1 IS THE BEST because:
✅ No metadata dependency
✅ No database query needed  
✅ Direct parameter passing
✅ Cannot fail
✅ Most efficient

SIMPLE FIX:
1. Pass saved_order_id as parameter to _update_position()
2. Pass it down to _create_new_position()
3. Use it directly instead of reading from metadata

This eliminates the entire failure mode!

================================================================================
