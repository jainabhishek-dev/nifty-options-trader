# strategies/base_strategy.py
"""
Base Strategy Class for Nifty Options Trading
Provides common functionality and interface for all trading strategies
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from kiteconnect import KiteConnect

from risk_management.options_risk_manager import OptionsRiskManager
from utils.market_utils import MarketDataManager
from config.settings import TradingConfig, OptionsConfig

logger = logging.getLogger(__name__)

@dataclass
class TradeSignal:
    """Trading signal generated by strategy"""
    symbol: str
    action: str  # CALL/PUT
    strike_price: float
    option_type: str  # CE/PE
    quantity: int
    confidence: int
    entry_price: float
    stop_loss: float
    target: float
    reason: str
    timestamp: datetime = datetime.now()

@dataclass
class OrderResult:
    """Result of order execution"""
    order_id: str
    status: str  # SUCCESS/FAILED/PENDING
    symbol: str
    quantity: int
    price: float
    message: str
    timestamp: datetime = datetime.now()

class BaseStrategy(ABC):
    """Base class for all trading strategies"""
    
    # Strategy metadata (to be overridden by subclasses)
    DISPLAY_NAME = "Base Strategy"
    DESCRIPTION = "Base class for all trading strategies"
    DEFAULT_PARAMETERS = {}
    RISK_LEVEL = "MEDIUM"
    MIN_CAPITAL = 10000
    SUPPORTED_MODES = ["BACKTEST", "PAPER", "LIVE"]
    
    def __init__(self, 
                 kite_client: KiteConnect,
                 risk_manager: OptionsRiskManager,
                 market_data: MarketDataManager,
                 **kwargs):
        """Initialize base strategy"""
        self.kite = kite_client
        self.risk_manager = risk_manager
        self.market_data = market_data
        
        # Strategy identification
        self.config_name: Optional[str] = None
        self.strategy_id: str = f"{self.__class__.__name__}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Strategy parameters (from kwargs)
        self.parameters = kwargs
        
        # Strategy state
        self.active_positions: Dict[str, Dict[str, Any]] = {}
        self.pending_orders: Dict[str, Dict[str, Any]] = {}
        self.strategy_pnl = 0.0
        self.is_active = False
        
        # Time context for backtesting vs live trading
        self.current_time_context: Optional[datetime] = None
        
        # Performance tracking
        self.total_signals = 0
        self.executed_signals = 0
        self.start_time: Optional[datetime] = None
        
        logger.info(f"🎯 {self.__class__.__name__} initialized with ID: {self.strategy_id}")
    
    @abstractmethod
    def generate_signals(self) -> List[TradeSignal]:
        """Generate trading signals (to be implemented by strategy subclasses)"""
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """Get strategy name for identification"""
        pass
    
    def _get_current_time(self) -> datetime:
        """Get current time - uses context for backtesting or real time for live trading"""
        if self.current_time_context:
            return self.current_time_context
        return datetime.now()
    
    def set_time_context(self, time_context: datetime):
        """Set time context for backtesting"""
        self.current_time_context = time_context
    
    def execute_trade(self, signal: TradeSignal) -> Optional[OrderResult]:
        """Execute a trade signal"""
        try:
            logger.info(f"🔄 Executing trade: {signal.symbol} {signal.action} {signal.quantity}")
            
            # Validate signal
            if not self._validate_signal(signal):
                return OrderResult(
                    order_id="",
                    status="FAILED",
                    symbol=signal.symbol,
                    quantity=signal.quantity,
                    price=signal.entry_price,
                    message="Signal validation failed"
                )
            
            # Place order based on trading mode
            if TradingConfig.TRADING_MODE == 'PAPER':
                return self._execute_paper_trade(signal)
            else:
                return self._execute_live_trade(signal)
                
        except Exception as e:
            logger.error(f"❌ Trade execution failed: {e}")
            return OrderResult(
                order_id="",
                status="FAILED",
                symbol=signal.symbol,
                quantity=signal.quantity,
                price=signal.entry_price,
                message=f"Execution error: {e}"
            )
    
    def _validate_signal(self, signal: TradeSignal) -> bool:
        """Validate trade signal before execution"""
        try:
            # Check basic signal validity
            if not signal.symbol or signal.quantity <= 0:
                logger.warning("🚫 Invalid signal: Missing symbol or quantity")
                return False
            
            # Check confidence threshold
            if signal.confidence < 6:
                logger.debug(f"🚫 Signal confidence too low: {signal.confidence}")
                return False
            
            # Check price reasonableness
            if signal.entry_price <= 0 or signal.entry_price > 1000:
                logger.warning(f"🚫 Unreasonable entry price: ₹{signal.entry_price}")
                return False
            
            # Check if we already have position in this symbol
            if signal.symbol in self.active_positions:
                logger.debug(f"🚫 Already have position in {signal.symbol}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"❌ Signal validation error: {e}")
            return False
    
    def _execute_paper_trade(self, signal: TradeSignal) -> OrderResult:
        """Execute trade in paper trading mode"""
        try:
            logger.info(f"📝 PAPER TRADE: {signal.symbol} {signal.action} {signal.quantity} @ ₹{signal.entry_price}")
            
            # Simulate order execution
            order_id = f"PAPER_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{signal.symbol}"
            
            # Record position
            self.active_positions[signal.symbol] = {
                'order_id': order_id,
                'symbol': signal.symbol,
                'quantity': signal.quantity,
                'entry_price': signal.entry_price,
                'entry_time': datetime.now(),
                'stop_loss': signal.stop_loss,
                'target': signal.target,
                'action': signal.action,
                'confidence': signal.confidence
            }
            
            # Update counters
            self.executed_signals += 1
            
            return OrderResult(
                order_id=order_id,
                status="SUCCESS",
                symbol=signal.symbol,
                quantity=signal.quantity,
                price=signal.entry_price,
                message="Paper trade executed successfully"
            )
            
        except Exception as e:
            logger.error(f"❌ Paper trade execution failed: {e}")
            return OrderResult(
                order_id="",
                status="FAILED",
                symbol=signal.symbol,
                quantity=signal.quantity,
                price=signal.entry_price,
                message=f"Paper trade failed: {e}"
            )
    
    def _execute_live_trade(self, signal: TradeSignal) -> OrderResult:
        """Execute trade in live trading mode"""
        try:
            logger.info(f"💰 LIVE TRADE: {signal.symbol} {signal.action} {signal.quantity} @ ₹{signal.entry_price}")
            
            # Place buy order
            order_params = {
                'variety': 'regular',
                'exchange': 'NFO',
                'tradingsymbol': signal.symbol,
                'transaction_type': 'BUY',
                'quantity': signal.quantity,
                'product': 'MIS',  # Intraday
                'order_type': 'LIMIT',
                'price': signal.entry_price,
                'validity': 'DAY'
            }
            
            # Execute order
            order_response = self.kite.place_order(**order_params)
            
            if isinstance(order_response, dict):
                order_id = order_response.get('order_id', '')
            else:
                order_id = str(order_response) if order_response else ""
            
            if order_id:
                # Record position
                self.active_positions[signal.symbol] = {
                    'order_id': order_id,
                    'symbol': signal.symbol,
                    'quantity': signal.quantity,
                    'entry_price': signal.entry_price,
                    'entry_time': datetime.now(),
                    'stop_loss': signal.stop_loss,
                    'target': signal.target,
                    'action': signal.action,
                    'confidence': signal.confidence
                }
                
                self.executed_signals += 1
                
                return OrderResult(
                    order_id=order_id,
                    status="SUCCESS",
                    symbol=signal.symbol,
                    quantity=signal.quantity,
                    price=signal.entry_price,
                    message=f"Live order placed: {order_id}"
                )
            else:
                return OrderResult(
                    order_id="",
                    status="FAILED",
                    symbol=signal.symbol,
                    quantity=signal.quantity,
                    price=signal.entry_price,
                    message="Failed to place live order"
                )
                
        except Exception as e:
            logger.error(f"❌ Live trade execution failed: {e}")
            return OrderResult(
                order_id="",
                status="FAILED",
                symbol=signal.symbol,
                quantity=signal.quantity,
                price=signal.entry_price,
                message=f"Live trade failed: {e}"
            )
    
    def monitor_positions(self) -> List[Dict[str, Any]]:
        """Monitor active positions and generate exit signals"""
        exit_signals = []
        
        try:
            current_time = datetime.now()
            
            for symbol, position in list(self.active_positions.items()):
                # Get current option price
                current_price = self._get_current_option_price(symbol)
                if current_price <= 0:
                    continue
                
                entry_price = position['entry_price']
                entry_time = position['entry_time']
                stop_loss = position['stop_loss']
                target = position['target']
                
                # Calculate P&L
                pnl_percent = ((current_price - entry_price) / entry_price) * 100
                
                # Check exit conditions
                exit_reason = None
                
                # Stop loss check
                if current_price <= stop_loss:
                    exit_reason = "STOP_LOSS"
                
                # Target check
                elif current_price >= target:
                    exit_reason = "TARGET_HIT"
                
                # Time-based exit (end of day)
                elif current_time.hour >= 15 and current_time.minute >= 15:
                    exit_reason = "EOD_EXIT"
                
                # Generate exit signal if needed
                if exit_reason:
                    exit_signal = {
                        'action': 'EXIT',
                        'symbol': symbol,
                        'quantity': position['quantity'],
                        'current_price': current_price,
                        'reason': exit_reason,
                        'pnl_percent': pnl_percent
                    }
                    
                    exit_signals.append(exit_signal)
                    logger.info(f"🚪 Exit signal: {symbol} - {exit_reason} (P&L: {pnl_percent:+.1f}%)")
                
                # Update position P&L
                position['current_price'] = current_price
                position['pnl_percent'] = pnl_percent
            
        except Exception as e:
            logger.error(f"❌ Position monitoring failed: {e}")
        
        return exit_signals
    
    def _get_current_option_price(self, symbol: str) -> float:
        """Get current option price"""
        try:
            # For paper trading, simulate price movement
            if TradingConfig.TRADING_MODE == 'PAPER':
                if symbol in self.active_positions:
                    entry_price = self.active_positions[symbol]['entry_price']
                    # Simple random walk for simulation
                    import random
                    change_percent = random.uniform(-0.1, 0.1)  # ±10% price movement
                    return entry_price * (1 + change_percent)
                return 0.0
            
            # For live trading, get actual quote
            quote_response = self.kite.quote([f"NFO:{symbol}"])
            
            if isinstance(quote_response, dict):
                option_data = quote_response.get(f"NFO:{symbol}", {})
                if isinstance(option_data, dict):
                    return float(option_data.get('last_price', 0))
            
            return 0.0
            
        except Exception as e:
            logger.error(f"❌ Failed to get current price for {symbol}: {e}")
            return 0.0
    
    def close_position(self, symbol: str, reason: str = "MANUAL") -> Optional[OrderResult]:
        """Close specific position"""
        try:
            if symbol not in self.active_positions:
                logger.warning(f"⚠️ No active position found for {symbol}")
                return None
            
            position = self.active_positions[symbol]
            current_price = self._get_current_option_price(symbol)
            
            logger.info(f"🚪 Closing position: {symbol} - Reason: {reason}")
            
            if TradingConfig.TRADING_MODE == 'PAPER':
                # Paper trading exit
                order_id = f"PAPER_EXIT_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{symbol}"
                
                # Calculate P&L
                entry_price = position['entry_price']
                quantity = position['quantity']
                pnl = (current_price - entry_price) * quantity
                
                # Remove from active positions
                del self.active_positions[symbol]
                
                return OrderResult(
                    order_id=order_id,
                    status="SUCCESS",
                    symbol=symbol,
                    quantity=quantity,
                    price=current_price,
                    message=f"Paper position closed: P&L ₹{pnl:.2f}"
                )
            
            else:
                # Live trading exit
                order_params = {
                    'variety': 'regular',
                    'exchange': 'NFO',
                    'tradingsymbol': symbol,
                    'transaction_type': 'SELL',
                    'quantity': position['quantity'],
                    'product': 'MIS',
                    'order_type': 'MARKET',
                    'validity': 'DAY'
                }
                
                order_response = self.kite.place_order(**order_params)
                
                if isinstance(order_response, dict):
                    order_id = order_response.get('order_id', '')
                else:
                    order_id = str(order_response) if order_response else ""
                
                if order_id:
                    del self.active_positions[symbol]
                    
                    return OrderResult(
                        order_id=order_id,
                        status="SUCCESS",
                        symbol=symbol,
                        quantity=position['quantity'],
                        price=current_price,
                        message=f"Live position closed: {order_id}"
                    )
                else:
                    return OrderResult(
                        order_id="",
                        status="FAILED",
                        symbol=symbol,
                        quantity=position['quantity'],
                        price=current_price,
                        message="Failed to place exit order"
                    )
                    
        except Exception as e:
            logger.error(f"❌ Failed to close position {symbol}: {e}")
            return OrderResult(
                order_id="",
                status="FAILED",
                symbol=symbol,
                quantity=0,
                price=0,
                message=f"Exit failed: {e}"
            )
    
    def close_all_positions(self) -> List[OrderResult]:
        """Close all active positions"""
        results = []
        
        for symbol in list(self.active_positions.keys()):
            result = self.close_position(symbol, "CLOSE_ALL")
            if result:
                results.append(result)
        
        logger.info(f"🚪 Closed {len(results)} positions")
        return results
    
    def close_eod_positions(self) -> List[OrderResult]:
        """Close positions at end of day"""
        return self.close_all_positions()
    
    def get_strategy_summary(self) -> Dict[str, Any]:
        """Get strategy performance summary"""
        try:
            total_pnl = 0.0
            active_count = len(self.active_positions)
            
            # Calculate unrealized P&L
            for symbol, position in self.active_positions.items():
                current_price = self._get_current_option_price(symbol)
                if current_price > 0:
                    entry_price = position['entry_price']
                    quantity = position['quantity']
                    unrealized_pnl = (current_price - entry_price) * quantity
                    total_pnl += unrealized_pnl
            
            success_rate = (self.executed_signals / max(1, self.total_signals)) * 100
            
            return {
                'strategy_name': self.get_strategy_name(),
                'total_signals': self.total_signals,
                'executed_signals': self.executed_signals,
                'success_rate': success_rate,
                'active_positions': active_count,
                'strategy_pnl': total_pnl,
                'trading_mode': TradingConfig.TRADING_MODE
            }
            
        except Exception as e:
            logger.error(f"❌ Failed to generate strategy summary: {e}")
            return {}

# Export classes
__all__ = ['BaseStrategy', 'TradeSignal', 'OrderResult']
